================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-27T14:40:10.670Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/
  commands/
    copyAllFiles.ts
    copyCodeBlock.ts
    copyFile.ts
    copyFileWithImports.ts
    index.ts
  extension.ts
package.json
package.nls.json

================================================================
Repository Files
================================================================

================
File: src/commands/copyAllFiles.ts
================
import * as vscode from 'vscode';
import * as path from 'path';

export class CopyAllFilesCommand {
    public static readonly commandName = 'clibbits.copyAllFiles';

    public static register(context: vscode.ExtensionContext): vscode.Disposable {
        return vscode.commands.registerCommand(this.commandName, async () => {
            const openEditors = vscode.window.tabGroups.all
                .flatMap(group => group.tabs)
                .filter(tab => tab.input instanceof vscode.TabInputText)
                .map(tab => (tab.input as vscode.TabInputText).uri);

            if (openEditors.length === 0) {
                vscode.window.showInformationMessage('No files are currently open.');
                return;
            }

            try {
                let combinedContent = '';

                for (const uri of openEditors) {
                    const document = await vscode.workspace.openTextDocument(uri);
                    const fileName = path.basename(document.fileName);
                    
                    combinedContent += `\n=== ${fileName} ===\n\n`;
                    combinedContent += document.getText();
                    combinedContent += '\n\n';
                }

                await vscode.env.clipboard.writeText(combinedContent);
                
                vscode.window.showInformationMessage(
                    `Successfully copied content from ${openEditors.length} file(s) to clipboard.`
                );
            } catch (error) {
                vscode.window.showErrorMessage(
                    `Failed to copy files: ${error instanceof Error ? error.message : 'Unknown error'}`
                );
            }
        });
    }
}

================
File: src/commands/copyCodeBlock.ts
================
import * as vscode from 'vscode';

export class CopyCodeBlockCommand {
    public static readonly commandName = 'clibbits.copyCodeBlock';

    private static findBlockBoundaries(document: vscode.TextDocument, lineNumber: number): { startLine: number; endLine: number } | undefined {
        // First, find the line containing the opening brace
        let startLine = lineNumber;
        let foundOpenBrace = false;
        
        // Search up until we find a line with an opening brace
        while (startLine >= 0) {
            const line = document.lineAt(startLine).text;
            if (line.includes('{')) {
                foundOpenBrace = true;
                break;
            }
            // Stop if we hit a closing brace while searching up
            if (line.includes('}')) {
                return undefined;
            }
            startLine--;
        }

        if (!foundOpenBrace) {
            return undefined;
        }

        // Now search for the matching closing brace
        let endLine = startLine;
        let braceCount = 0;
        const maxLines = document.lineCount - 1;

        while (endLine <= maxLines) {
            const lineText = document.lineAt(endLine).text;
            
            // Count braces on this line
            const openBraces = (lineText.match(/{/g) || []).length;
            const closeBraces = (lineText.match(/}/g) || []).length;
            
            braceCount += openBraces;
            braceCount -= closeBraces;

            // If we've found the matching closing brace
            if (braceCount === 0 && closeBraces > 0) {
                break;
            }

            // Prevent infinite loops in malformed files
            if (endLine - startLine > 1000) {
                return undefined;
            }

            endLine++;
        }

        // If we couldn't find a matching closing brace
        if (endLine > maxLines || braceCount !== 0) {
            return undefined;
        }

        // Find the real start of the block (including function declaration)
        while (startLine > 0) {
            const previousLine = document.lineAt(startLine - 1).text.trim();
            // Stop if we hit an empty line or another closing brace
            if (previousLine === '' || previousLine.includes('}')) {
                break;
            }
            startLine--;
        }

        return { startLine, endLine };
    }

    public static register(context: vscode.ExtensionContext): vscode.Disposable {
        return vscode.commands.registerTextEditorCommand(
            this.commandName,
            async (textEditor: vscode.TextEditor) => {
                try {
                    const document = textEditor.document;
                    const position = textEditor.selection.active;
                    
                    // Find the block boundaries
                    const boundaries = this.findBlockBoundaries(document, position.line);
                    
                    if (!boundaries) {
                        vscode.window.showInformationMessage('No code block detected at cursor position.');
                        return;
                    }

                    // Extract the text from the detected block
                    const startPos = new vscode.Position(boundaries.startLine, 0);
                    const endPos = new vscode.Position(
                        boundaries.endLine, 
                        document.lineAt(boundaries.endLine).text.length
                    );
                    const blockText = document.getText(new vscode.Range(startPos, endPos));

                    if (!blockText.trim()) {
                        vscode.window.showInformationMessage('No code block detected at cursor position.');
                        return;
                    }

                    // Copy to clipboard
                    await vscode.env.clipboard.writeText(blockText);
                    
                    // Show success message with the first line of the copied block
                    const firstLine = blockText.split('\n')[0].trim();
                    const previewText = firstLine.length > 50 ? firstLine.substring(0, 47) + '...' : firstLine;
                    vscode.window.showInformationMessage(`Copied block: ${previewText}`);

                    // Briefly highlight the copied block for visual feedback
                    const decoration = vscode.window.createTextEditorDecorationType({
                        backgroundColor: new vscode.ThemeColor('editor.selectionHighlightBackground'),
                    });
                    
                    textEditor.setDecorations(decoration, [new vscode.Range(startPos, endPos)]);
                    
                    // Remove the highlight after a short delay
                    setTimeout(() => {
                        decoration.dispose();
                    }, 500);

                } catch (error) {
                    vscode.window.showErrorMessage(
                        `Failed to copy code block: ${error instanceof Error ? error.message : 'Unknown error'}`
                    );
                }
            }
        );
    }
}

================
File: src/commands/copyFile.ts
================
import * as vscode from 'vscode';
import * as path from 'path';

export class CopyFileCommand {
    public static readonly commandName = 'clibbits.copyFile';

    public static register(context: vscode.ExtensionContext): vscode.Disposable {
        return vscode.commands.registerCommand(
            this.commandName,
            async (uri: vscode.Uri, selectedFiles: vscode.Uri[]) => {
                try {
                    let urisToProcess: vscode.Uri[] = [];

                    // Check if this is a multi-selection context menu action
                    if (selectedFiles && Array.isArray(selectedFiles)) {
                        urisToProcess = selectedFiles;
                    } 
                    // Single file from explorer context menu
                    else if (uri) {
                        urisToProcess = [uri];
                    }
                    // Called from command palette - use active editor
                    else if (vscode.window.activeTextEditor) {
                        urisToProcess = [vscode.window.activeTextEditor.document.uri];
                    }

                    if (urisToProcess.length === 0) {
                        vscode.window.showInformationMessage('No files selected.');
                        return;
                    }

                    let combinedContent = '';
                    let successfulCopies = 0;
                    let totalSize = 0;

                    for (const fileUri of urisToProcess) {
                        try {
                            const document = await vscode.workspace.openTextDocument(fileUri);
                            const content = document.getText();
                            const fileName = path.basename(fileUri.fsPath);
                            
                            // Add file separator if this isn't the first file
                            if (successfulCopies > 0) {
                                combinedContent += '\n\n';
                            }

                            // Only add headers if there are multiple files
                            if (urisToProcess.length > 1) {
                                combinedContent += `=== ${fileName} ===\n\n`;
                            }
                            
                            combinedContent += content;
                            successfulCopies++;
                            totalSize += content.length;

                            // Check if we're exceeding a reasonable size limit (e.g., 5MB)
                            if (totalSize > 5 * 1024 * 1024) {
                                throw new Error('Combined file size exceeds 5MB limit');
                            }
                        } catch (error) {
                            vscode.window.showWarningMessage(
                                `Failed to copy ${path.basename(fileUri.fsPath)}: ${error instanceof Error ? error.message : 'Unknown error'}`
                            );
                        }
                    }

                    if (successfulCopies > 0) {
                        await vscode.env.clipboard.writeText(combinedContent);
                        
                        const message = successfulCopies === 1
                            ? `Successfully copied contents of ${path.basename(urisToProcess[0].fsPath)} to clipboard.`
                            : `Successfully copied contents of ${successfulCopies} files to clipboard.`;
                        
                        vscode.window.showInformationMessage(message);
                    }
                } catch (error) {
                    vscode.window.showErrorMessage(
                        `Failed to copy files: ${error instanceof Error ? error.message : 'Unknown error'}`
                    );
                }
            }
        );
    }
}

================
File: src/commands/copyFileWithImports.ts
================
import * as vscode from "vscode";
import * as path from "path";
import * as fs from "fs";

export class CopyWithImportsCommand {
  public static readonly commandName = "clibbits.copyWithImports";

  public static register(context: vscode.ExtensionContext): vscode.Disposable {
    return vscode.commands.registerCommand(
      this.commandName,
      async (uri: vscode.Uri, selectedFiles: vscode.Uri[]) => {
        try {
          let urisToProcess: vscode.Uri[] = [];

          // Handle different command invocation contexts
          if (selectedFiles && Array.isArray(selectedFiles)) {
            // Multi-selection in explorer
            urisToProcess = selectedFiles;
          } else if (uri) {
            // Single file from explorer context menu
            urisToProcess = [uri];
          } else if (vscode.window.activeTextEditor) {
            // Called from command palette - use active editor
            urisToProcess = [vscode.window.activeTextEditor.document.uri];
          }

          if (urisToProcess.length === 0) {
            vscode.window.showInformationMessage("No files selected.");
            return;
          }

          // Show progress indicator
          await vscode.window.withProgress(
            {
              location: vscode.ProgressLocation.Notification,
              title: "Collecting files with imports...",
              cancellable: false,
            },
            async (progress) => {
              let totalProcessed = 0;
              let combinedContent = "";
              let totalSize = 0;

              for (const fileUri of urisToProcess) {
                try {
                  const files = await this.processFileWithImports(
                    fileUri.fsPath
                  );

                  for (const file of files) {
                    const relativePath = path.relative(
                      vscode.workspace.getWorkspaceFolder(fileUri)?.uri
                        .fsPath || "",
                      file.path
                    );

                    // Add separator between files
                    if (totalProcessed > 0) {
                      combinedContent += "\n";
                    }

                    combinedContent += `${"=".repeat(80)}\n`;
                    combinedContent += `// File: ${relativePath}\n`;
                    combinedContent += `${"=".repeat(80)}\n\n`;
                    combinedContent += `${file.content}\n`;

                    totalProcessed++;
                    totalSize += file.content.length;

                    // Check size limit (5MB)
                    if (totalSize > 5 * 1024 * 1024) {
                      throw new Error("Combined file size exceeds 5MB limit");
                    }

                    progress.report({
                      message: `Processed ${totalProcessed} files`,
                      increment: (1 / files.length) * 100,
                    });
                  }
                } catch (error) {
                  vscode.window.showWarningMessage(
                    `Failed to process ${path.basename(fileUri.fsPath)}: ${
                      error instanceof Error ? error.message : "Unknown error"
                    }`
                  );
                }
              }

              if (totalProcessed > 0) {
                await vscode.env.clipboard.writeText(combinedContent);

                const message =
                  totalProcessed === 1
                    ? `Successfully copied file with its imports to clipboard.`
                    : `Successfully copied ${totalProcessed} files with their imports to clipboard.`;

                vscode.window.showInformationMessage(message);
              }
            }
          );
        } catch (error) {
          vscode.window.showErrorMessage(
            `Failed to copy files: ${
              error instanceof Error ? error.message : "Unknown error"
            }`
          );
        }
      }
    );
  }

  private static outputChannel: vscode.OutputChannel =
    vscode.window.createOutputChannel("Clibbits Debug");

  private static log(message: string) {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }

  private static async findPubspecYaml(
    startPath: string
  ): Promise<{ projectRoot: string; projectName: string } | null> {
    this.log(`Looking for pubspec.yaml starting from: ${startPath}`);

    let currentPath = startPath;
    while (currentPath !== path.dirname(currentPath)) {
      const pubspecPath = path.join(currentPath, "pubspec.yaml");
      this.log(`Checking for pubspec at: ${pubspecPath}`);

      if (fs.existsSync(pubspecPath)) {
        try {
          const pubspecContent = fs.readFileSync(pubspecPath, "utf8");
          const nameMatch = pubspecContent.match(/^name:\s*(.+)$/m);
          if (nameMatch) {
            const projectName = nameMatch[1].trim();
            this.log(`Found project name: ${projectName} at ${currentPath}`);
            return {
              projectRoot: currentPath,
              projectName: projectName,
            };
          }
        } catch (error) {
          this.log(`Error reading pubspec.yaml: ${error}`);
        }
      }
      currentPath = path.dirname(currentPath);
    }

    this.log("No pubspec.yaml found");
    return null;
  }

  private static async resolvePackageImport(
    packageImport: string,
    currentFilePath: string
  ): Promise<string | null> {
    this.log(`\nResolving package import: ${packageImport}`);
    this.log(`Current file: ${currentFilePath}`);

    // Find the project root containing pubspec.yaml and get project name
    const projectInfo = await this.findPubspecYaml(
      path.dirname(currentFilePath)
    );
    if (!projectInfo) {
      this.log("Could not find project info");
      return null;
    }

    // Extract package name and relative path from import
    const match = packageImport.match(/^package:([^\/]+)\/(.+)$/);
    if (!match) {
      this.log("Invalid package import format");
      return null;
    }

    const [_, packageName, relativePath] = match;
    this.log(`Package name: ${packageName}`);
    this.log(`Relative path: ${relativePath}`);

    // For local package imports (matching project name)
    if (packageName === projectInfo.projectName) {
      const localPath = path.join(projectInfo.projectRoot, "lib", relativePath);
      this.log(`Checking local path: ${localPath}`);

      if (fs.existsSync(localPath)) {
        this.log(`Found local file at: ${localPath}`);
        return localPath;
      }
      this.log("Local file not found");
    }

    // Check package_config.json
    const packageConfigPath = path.join(
      projectInfo.projectRoot,
      ".dart_tool",
      "package_config.json"
    );
    this.log(`Checking for package_config.json at: ${packageConfigPath}`);

    if (fs.existsSync(packageConfigPath)) {
      try {
        const packageConfig = JSON.parse(
          fs.readFileSync(packageConfigPath, "utf8")
        );
        this.log("Found package_config.json");

        const packageEntry = packageConfig.packages.find(
          (p: any) => p.name === packageName
        );
        if (packageEntry) {
          this.log(`Found package entry: ${JSON.stringify(packageEntry)}`);

          let packagePath = packageEntry.rootUri;
          if (packagePath.startsWith("file://")) {
            packagePath = packagePath.substring(7);
          }

          // Try different possible paths
          const possiblePaths = [
            path.join(packagePath, relativePath),
            path.join(packagePath, "lib", relativePath),
          ];

          for (const tryPath of possiblePaths) {
            this.log(`Trying path: ${tryPath}`);
            if (fs.existsSync(tryPath)) {
              this.log(`Found file at: ${tryPath}`);
              return tryPath;
            }
          }

          this.log("No valid paths found");
        } else {
          this.log(`Package ${packageName} not found in package_config.json`);
        }
      } catch (error) {
        this.log(`Error reading package_config.json: ${error}`);
      }
    } else {
      this.log("package_config.json not found");
    }

    this.log("Failed to resolve package import");
    return null;
  }

  private static async findImports(
    document: vscode.TextDocument
  ): Promise<Set<string>> {
    this.log(`\nFinding imports in file: ${document.uri.fsPath}`);
    const imports = new Set<string>();
    const text = document.getText();

    const importPatterns = [
      { pattern: /import\s+['"]package:([^'"]+)['"]/g, type: "package import" },
      {
        pattern: /import\s+['"](\.{1,2}\/[^'"]+)['"]/g,
        type: "relative import",
      },
      { pattern: /export\s+['"]package:([^'"]+)['"]/g, type: "package export" },
      {
        pattern: /export\s+['"](\.{1,2}\/[^'"]+)['"]/g,
        type: "relative export",
      },
      { pattern: /part\s+['"]([^'"]+)['"]/g, type: "part" },
    ];

    for (const { pattern, type } of importPatterns) {
      let match;
      while ((match = pattern.exec(text)) !== null) {
        const importPath = match[1];
        this.log(`\nFound ${type}: ${importPath}`);

        let resolvedPath: string | null = null;

        if (importPath.startsWith("package:")) {
          resolvedPath = await this.resolvePackageImport(
            importPath,
            document.uri.fsPath
          );
        } else if (importPath.startsWith(".")) {
          const currentDir = path.dirname(document.uri.fsPath);
          resolvedPath = path.resolve(currentDir, importPath);

          if (!resolvedPath.endsWith(".dart")) {
            resolvedPath += ".dart";
          }

          this.log(`Resolved relative path to: ${resolvedPath}`);
        }

        if (resolvedPath && fs.existsSync(resolvedPath)) {
          this.log(`Successfully resolved to: ${resolvedPath}`);
          imports.add(resolvedPath);
        } else {
          this.log(`Failed to resolve path: ${importPath}`);
        }
      }
    }

    this.log(`Found ${imports.size} valid imports`);
    return imports;
  }

  private static async processFileWithImports(
    filePath: string,
    processedFiles: Set<string> = new Set()
  ): Promise<{ path: string; content: string }[]> {
    if (processedFiles.has(filePath)) {
      return [];
    }

    processedFiles.add(filePath);
    const results: { path: string; content: string }[] = [];

    try {
      const document = await vscode.workspace.openTextDocument(filePath);
      results.push({
        path: filePath,
        content: document.getText(),
      });

      // Find and process imports recursively
      const imports = await this.findImports(document);
      for (const importPath of imports) {
        const importedFiles = await this.processFileWithImports(
          importPath,
          processedFiles
        );
        results.push(...importedFiles);
      }
    } catch (error) {
      console.error(`Error processing file ${filePath}:`, error);
    }

    return results;
  }

  // ... rest of the class implementation remains the same ...
}

================
File: src/commands/index.ts
================
export * from './copyAllFiles';
export * from './copyFile';
export * from './copyCodeBlock';
export * from './copyFileWithImports';

================
File: src/extension.ts
================
import * as vscode from "vscode";
import {
  CopyAllFilesCommand,
  CopyCodeBlockCommand,
  CopyFileCommand,
  CopyWithImportsCommand,
} from "./commands";

export function activate(context: vscode.ExtensionContext) {
  console.log("Activating Clibbits extension");

  context.subscriptions.push(
    CopyAllFilesCommand.register(context),
    CopyFileCommand.register(context),
    CopyCodeBlockCommand.register(context),
    CopyWithImportsCommand.register(context)
  );
}

export function deactivate() {}

================
File: package.json
================
{
  "name": "clibbits",
  "displayName": "Clibbits: Copy Code For AI",
  "description": "Copy contents of files to clipboard",
  "version": "2.0.0",
  "publisher": "CodeontheRocks",
  "icon": "clibbits.png",
  "repository": {
    "type": "git",
    "url": "https://github.com/jtmuller5/clibbits"
  },
  "engines": {
    "vscode": "^1.60.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onCommand:clibbits.copyAllFiles",
    "onCommand:clibbits.copyFile"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "clibbits.copyAllFiles",
        "title": "Clibbits: Copy All Open Files to Clipboard",
        "icon": "$(copy)"
      },
      {
        "command": "clibbits.copyFile",
        "title": "Clibbits: Copy File Contents to Clipboard",
        "icon": "$(copy)"
      },
      {
        "command": "clibbits.copyCodeBlock",
        "title": "Clibbits: Copy Code Block to Clipboard",
        "icon": "$(copy)"
      }
    ],
    "menus": {
      "explorer/context": [
        {
          "command": "clibbits.copyFile",
          "group": "navigation@1",
          "when": "explorerViewletVisible"
        }
      ],
      "editor/context": [
        {
          "command": "clibbits.copyFile",
          "group": "navigation@1",
          "when": "resourceScheme == file"
        },
        {
          "command": "clibbits.copyCodeBlock",
          "group": "navigation@2",
          "when": "editorTextFocus"
        },
        {
          "command": "clibbits.copyAllFiles",
          "group": "navigation@3",
          "when": "editorTextFocus"
        }
      ]
    },
    "keybindings": [
      {
        "command": "clibbits.copyAllFiles",
        "key": "ctrl+shift+c",
        "mac": "cmd+shift+c",
        "when": "editorTextFocus"
      },
      {
        "command": "clibbits.copyCodeBlock",
        "key": "ctrl+shift+b",
        "mac": "cmd+shift+b",
        "when": "editorTextFocus"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "pretest": "npm run compile && npm run lint",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js"
  },
  "devDependencies": {
    "@types/vscode": "^1.60.0",
    "@types/node": "14.x",
    "@typescript-eslint/eslint-plugin": "^5.1.0",
    "@typescript-eslint/parser": "^5.1.0",
    "eslint": "^8.1.0",
    "typescript": "^4.4.4"
  }
}

================
File: package.nls.json
================
{
    "clibbits.snippetMenu": "Clibbits Snippets",
    "clibbits.copySnippet": "Copy: {0}"
  }
